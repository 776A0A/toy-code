<script>
  let usedReactivities = new Map()
  const handlers = new Map()
  const reactivities = new Map()

  function reactive(obj) {
    if (reactivities.get(obj)) return reactivities.get(obj)

    const proxy = new Proxy(obj, {
      get(obj, prop) {
        !usedReactivities.get(obj) && usedReactivities.set(obj, prop)
        if (typeof obj[prop] === 'object' && obj[prop]) return reactive(obj[prop]) // 递归
        return obj[prop]
      },
      set(obj, prop, val) {
        if (typeof val === 'object' && val) {
          obj[prop] = reactive(val)
          const oHandlers = handlers.get(obj)?.get(prop)
          oHandlers.forEach(effect) // 重新触发依赖收集
        }
        else obj[prop] = val
        handlers.get(obj)?.get(prop)?.forEach(handler => handler())
        return obj[prop]
      }
    })
    // 缓存同一对象的proxy
    reactivities.set(obj, proxy)
    reactivities.set(proxy, proxy)
    return proxy
  }

  function effect(handler) {
    usedReactivities.clear()
    handler()
    for (const reactivity of usedReactivities) {
      const [obj, prop] = reactivity
      if (!handlers.get(obj)) {
        handlers.set(obj, new Map())
      }
      if (!handlers.get(obj).get(prop)) {
        handlers.get(obj).set(prop, new Set())
      }
      handlers.get(obj).get(prop).add(handler)
    }
  }

  let res
  const c = reactive({ a: { b: 0 } })
  effect(() => (res = c.a.b))
  console.log(res);
  c.a.b = 1
  console.log(res);
  c.a = { b: 2 }
  console.log(res);
  c.a.b = 3
  console.log(res);
  c.a = { b: 4 }
  console.log(res);
  c.a.b = 5
  console.log(res);

</script>